import SeedGenerator from './seedGenerator';

type Cell = { cellType: 'wall' | 'empty', floorImage?: string };

interface Room {
  h: number;
  w: number;
  row: number;
  col: number;
}

interface Config {
  rows?: number;
  cols?: number;
  maxRoomSize?: number;
  minRoomSize?: number;
  padding?: number;
  maxAttempts?: number;
  rooms?: number;
}

// const floorImages = ['floor1.png', 'floor2.png', 'floor3.png', 'floor4.png', 'floor5.png'];
// const floorImages = ['grass.png'];
const floorImages = ['floor68.png', 'floor70.png'];

class DungeonGenerator {
  private static WALL: Cell = { cellType: 'wall' };
  private static EMPTY: Cell = { cellType: 'empty' };

  private static ROWS: number;
  private static COLS: number;
  private static MAXSIZE: number;
  private static MINSIZE: number;
  private static BORDER: number;
  private static ATTEMPTS: number;
  private static ROOMS: number;

  private static rooms: Room[] = [];
  private static rng: SeedGenerator | null = null;

  private static isNotOverlapping(floorMap: Cell[][], room: Room): boolean {
    for (let i = room.row - 1; i < room.row + room.h + 1; i++) {
      for (let j = room.col - 1; j < room.col + room.w + 1; j++) {
        if (floorMap[i][j].cellType !== DungeonGenerator.WALL.cellType) {
          return false;
        }
      }
    }
    return true;
  }

  private static linkStraightH(floorMap: Cell[][], r1: Room, r2: Room) {
    const inc = r1.col < r2.col ? 1 : -1;
    for (let i = r1.col; i !== r2.col; i += inc) {
        floorMap[r1.row][i] = { ...DungeonGenerator.EMPTY };
        floorMap[r1.row + 1][i] = { ...DungeonGenerator.EMPTY };
    }
  }

  private static linkStraightV(floorMap: Cell[][], r1: Room, r2: Room) {
    const inc = r1.row < r2.row ? 1 : -1;
    for (let i = r1.row; i !== r2.row; i += inc) {
        floorMap[i][r1.col] = { ...DungeonGenerator.EMPTY };
        floorMap[i][r1.col + 1] = { ...DungeonGenerator.EMPTY };
    }
  }

  private static link2Steps(floorMap: Cell[][], r1: Room, r2: Room): boolean {
    const flipCoin = this.rng ? Math.floor(this.rng.nextFloat() * 2) : Math.floor(Math.random() * 2);
    if (r1.row > r2.row && r1.col > r2.col) {
        if (flipCoin) {
            for (let i = r1.row - 1; i >= r2.row + r2.h - 1; i--) {
                floorMap[i][r1.col] = { ...DungeonGenerator.EMPTY };
                floorMap[i][r1.col + 1] = { ...DungeonGenerator.EMPTY };
            }
            for (let i = r1.col - 1; i >= r2.col + r2.w; i--) {
                floorMap[r2.row + r2.h - 1][i] = { ...DungeonGenerator.EMPTY };
                floorMap[r2.row + r2.h - 2][i] = { ...DungeonGenerator.EMPTY };
            }
        } else {
            for (let i = r1.col - 1; i >= r2.col + r2.w - 1; i--) {
                floorMap[r1.row][i] = { ...DungeonGenerator.EMPTY };
                floorMap[r1.row + 1][i] = { ...DungeonGenerator.EMPTY };
            }
            for (let i = r1.row - 1; i >= r2.row + r2.h; i--) {
                floorMap[i][r2.col + r2.w - 1] = { ...DungeonGenerator.EMPTY };
                floorMap[i][r2.col + r2.w - 2] = { ...DungeonGenerator.EMPTY };
            }
        }
    } else if (r1.row > r2.row && r1.col < r2.col) {
        if (flipCoin) {
            for (let i = r1.row - 1; i >= r2.row + r2.h - 1; i--) {
                floorMap[i][r1.col + r1.w - 1] = { ...DungeonGenerator.EMPTY };
                floorMap[i][r1.col + r1.w] = { ...DungeonGenerator.EMPTY };
            }
            for (let i = r1.col + r1.w; i < r2.col; i++) {
                floorMap[r2.row + r2.h - 1][i] = { ...DungeonGenerator.EMPTY };
                floorMap[r2.row + r2.h - 2][i] = { ...DungeonGenerator.EMPTY };
            }
        } else {
            for (let i = r1.col + r1.w; i <= r2.col; i++) {
                floorMap[r1.row][i] = { ...DungeonGenerator.EMPTY };
                floorMap[r1.row + 1][i] = { ...DungeonGenerator.EMPTY };
            }
            for (let i = r1.row - 1; i >= r2.row + r2.h; i--) {
                floorMap[i][r2.col] = { ...DungeonGenerator.EMPTY };
                floorMap[i][r2.col + 1] = { ...DungeonGenerator.EMPTY };
            }
        }
    } else {
        return false;
    }
    return true;
  }

  private static linkRooms(floorMap: Cell[][], r1: Room, r2: Room) {
    if (r1.row >= r2.row && r1.row < r2.row + r2.h) {
      DungeonGenerator.linkStraightH(floorMap, r1, r2);
    } else if (r2.row >= r1.row && r2.row < r1.row + r1.h) {
      DungeonGenerator.linkStraightH(floorMap, r2, r1);
    } else if (r1.col >= r2.col && r1.col < r2.col + r2.w) {
      DungeonGenerator.linkStraightV(floorMap, r1, r2);
    } else if (r2.col >= r1.col && r2.col < r1.col + r1.w) {
      DungeonGenerator.linkStraightV(floorMap, r2, r1);
    } else {
      if (!DungeonGenerator.link2Steps(floorMap, r1, r2)) {
        DungeonGenerator.link2Steps(floorMap, r2, r1);
      }
    }
  }

  private static randomEvenOdd(min: number, max: number): number {
    if (max === min) return max;
    const randomValue = this.rng ? this.rng.nextFloat() : Math.random();
    return min + Math.floor(randomValue * Math.floor((max - min) / 2 + 1)) * 2;
  }

  private static addRoom(floorMap: Cell[][]): Room | undefined {
    const h = DungeonGenerator.randomEvenOdd(DungeonGenerator.MINSIZE, DungeonGenerator.MAXSIZE);
    const w = DungeonGenerator.randomEvenOdd(DungeonGenerator.MINSIZE, DungeonGenerator.MAXSIZE);
    const room: Room = {
      h,
      w,
      row: DungeonGenerator.randomEvenOdd(0, DungeonGenerator.ROWS - h - 2 * DungeonGenerator.BORDER) + DungeonGenerator.BORDER,
      col: DungeonGenerator.randomEvenOdd(0, DungeonGenerator.COLS - w - 2 * DungeonGenerator.BORDER) + DungeonGenerator.BORDER,
    };

    if (DungeonGenerator.isNotOverlapping(floorMap, room)) {
      for (let i = room.row; i < room.row + room.h; i++) {
        for (let j = room.col; j < room.col + room.w; j++) {
          floorMap[i][j] = { ...DungeonGenerator.EMPTY };
        }
      }
      return room;
    }
    return undefined;
  }

  private static distance(a: Room, b: Room): number {
    const d2 = Math.pow(b.row - a.row, 2) + Math.pow(b.col - a.col, 2);
    return Math.sqrt(d2);
  }

  public static generate(config: Config = {}, seed?: number): Cell[][] {
    DungeonGenerator.ROWS = config.rows || 31;
    DungeonGenerator.COLS = config.cols || 51;
    DungeonGenerator.MAXSIZE = config.maxRoomSize || 7;
    DungeonGenerator.MINSIZE = config.minRoomSize || 3;
    DungeonGenerator.BORDER = config.padding || 2;
    DungeonGenerator.ATTEMPTS = config.maxAttempts || 500;
    DungeonGenerator.ROOMS = config.rooms || 15;

    if (seed !== undefined) {
      DungeonGenerator.rng = new SeedGenerator(seed);
    } else {
      DungeonGenerator.rng = null;
    }

    const floorMap: Cell[][] = [];
    for (let i = 0; i < DungeonGenerator.ROWS; i++) {
      const row: Cell[] = [];
      for (let j = 0; j < DungeonGenerator.COLS; j++) {
        row.push({ ...DungeonGenerator.WALL });
      }
      floorMap.push(row);
    }

    const roomsToLink: Room[] = [];
    const roomsLinked: Room[] = [];
    let i = 0;
    let r = 0;
    while (i < DungeonGenerator.ATTEMPTS && r < DungeonGenerator.ROOMS) {
      const newRoom = DungeonGenerator.addRoom(floorMap);
      if (newRoom) {
        roomsToLink.push(newRoom);
        r++;
      }
      i++;
    }

    roomsLinked.push(roomsToLink.pop()!);
    while (roomsToLink.length) {
      const r1 = roomsLinked[roomsLinked.length - 1];
      const r2 = roomsToLink.sort((a, b) => DungeonGenerator.distance(r1, a) - DungeonGenerator.distance(r1, b)).pop()!;
      DungeonGenerator.linkRooms(floorMap, r1, r2);
      roomsLinked.push(r2);
    }

    this.rooms = roomsLinked;

    return floorMap.map(row =>
      row.map(cell => ({
        ...cell,
        floorImage: cell.cellType === DungeonGenerator.WALL.cellType ? '' : floorImages[Math.floor(Math.random() * floorImages.length)],
      }))
    );
  }

  public static getSpawnPoint(): { x: number, y: number } | undefined {
    if (this.rooms.length > 0) {
      const room = this.rooms[0];
      return {
        x: (room.col + Math.floor(room.w / 2)) * 20,
        y: (room.row + Math.floor(room.h / 2)) * 20,
      };
    }
    return undefined;
  }
}

export default DungeonGenerator;

<template>
  <div class="dungeon-map">
    <div v-for="(row, rowIndex) in dungeonMap" :key="rowIndex" class="row">
        <div v-for="(cell, colIndex) in row" :key="colIndex" :class="cell.cellType" :style="getCellStyle(cell)"></div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import DungeonGenerator from '../plugins/dungeonGenerator';
import { useDungeonStore } from '../stores/dungeon';

const dungeonStore = useDungeonStore();

type Cell = { cellType: 'wall' | 'empty', floorImage?: string };
const dungeonMap = ref<Cell[][]>([]);
const spawnPoint = ref<{ x: number, y: number } | undefined>(undefined);

onMounted(() => {
    const config = {
        rows: 31,
        cols: 51,
        maxRoomSize: 20,
        minRoomSize: 5,
        padding: 0,
        maxAttempts: 500,
        rooms: 50
    };
    const seed = 12345;
    dungeonMap.value = DungeonGenerator.generate(config, seed);
    spawnPoint.value = DungeonGenerator.getSpawnPoint();
    dungeonStore.setDungeon(dungeonMap.value);
    if (spawnPoint.value) {
      dungeonStore.setSpawnPoint(spawnPoint.value);
    }
});

const getCellStyle = (cell: Cell) => {
  if (cell.cellType === 'empty') {
    return { backgroundImage: `url(/src/assets/${cell.floorImage})` };
  }
  return {};
};
</script>

<style scoped>
.dungeon-map {
  --cell-size: 20px; /* default cell size */
  display: grid;
  grid-template-columns: repeat(51, var(--cell-size)); /* Assuming 51 columns */
  grid-gap: 0px;
}
.row {
  display: contents;
}
.wall {
  background-color: #000;
  width: var(--cell-size);
  height: var(--cell-size);
  /* background-image: url('/src/assets/floor69.png'); */
}
.empty {
  width: var(--cell-size);
  height: var(--cell-size);
}
</style>

import { defineStore } from 'pinia';

type Cell = { cellType: 'wall' | 'empty' };

interface DungeonState {
    dungeon: Cell[][];
    spawnPoint: { x: number, y: number };
}

export const useDungeonStore = defineStore('dungeon', {
    state: (): DungeonState => ({
      dungeon: [],
      spawnPoint: { x: 0, y: 0 }
    }),
    actions: {
      setDungeon(map: Cell[][]) {
        this.dungeon = map;
      },
      setSpawnPoint(coords: { x: number, y: number }) {
        this.spawnPoint = coords;
      },
    }
});
  