// src/plugins/dungeonGenerator.ts

type CellType = 'W' | 'E';
type Cell = { cellType: 'wall' | 'empty' };

interface Room {
  h: number;
  w: number;
  row: number;
  col: number;
}

interface Config {
  rows?: number;
  cols?: number;
  maxRoomSize?: number;
  minRoomSize?: number;
  padding?: number;
  maxAttempts?: number;
  rooms?: number;
}

class DungeonGenerator {
  private static WALL: CellType = 'W';
  private static EMPTY: CellType = 'E';

  private static ROWS: number;
  private static COLS: number;
  private static MAXSIZE: number;
  private static MINSIZE: number;
  private static BORDER: number;
  private static ATTEMPTS: number;
  private static ROOMS: number;

  private static isNotOverlapping(floorMap: CellType[][], room: Room): boolean {
    for (let i = room.row - 1; i < room.row + room.h + 1; i++) {
      for (let j = room.col - 1; j < room.col + room.w + 1; j++) {
        if (floorMap[i][j] !== DungeonGenerator.WALL) {
          return false;
        }
      }
    }
    return true;
  }

  private static linkStraightH(floorMap: CellType[][], r1: Room, r2: Room) {
    const inc = r1.col < r2.col ? 1 : -1;
    for (let i = r1.col; i !== r2.col; i += inc) {
      floorMap[r1.row][i] = DungeonGenerator.EMPTY;
    }
  }

  private static linkStraightV(floorMap: CellType[][], r1: Room, r2: Room) {
    const inc = r1.row < r2.row ? 1 : -1;
    for (let i = r1.row; i !== r2.row; i += inc) {
      floorMap[i][r1.col] = DungeonGenerator.EMPTY;
    }
  }

  private static link2Steps(floorMap: CellType[][], r1: Room, r2: Room): boolean {
    const flipCoin = Math.floor(Math.random() * 2);
    if (r1.row > r2.row && r1.col > r2.col) {
      if (flipCoin) {
        for (let i = r1.row - 1; i >= r2.row + r2.h - 1; i--) {
          floorMap[i][r1.col] = DungeonGenerator.EMPTY;
        }
        for (let i = r1.col - 1; i >= r2.col + r2.w; i--) {
          floorMap[r2.row + r2.h - 1][i] = DungeonGenerator.EMPTY;
        }
      } else {
        for (let i = r1.col - 1; i >= r2.col + r2.w - 1; i--) {
          floorMap[r1.row][i] = DungeonGenerator.EMPTY;
        }
        for (let i = r1.row - 1; i >= r2.row + r2.h; i--) {
          floorMap[i][r2.col + r2.w - 1] = DungeonGenerator.EMPTY;
        }
      }
    } else if (r1.row > r2.row && r1.col < r2.col) {
      if (flipCoin) {
        for (let i = r1.row - 1; i >= r2.row + r2.h - 1; i--) {
          floorMap[i][r1.col + r1.w - 1] = DungeonGenerator.EMPTY;
        }
        for (let i = r1.col + r1.w; i < r2.col; i++) {
          floorMap[r2.row + r2.h - 1][i] = DungeonGenerator.EMPTY;
        }
      } else {
        for (let i = r1.col + r1.w; i <= r2.col; i++) {
          floorMap[r1.row][i] = DungeonGenerator.EMPTY;
        }
        for (let i = r1.row - 1; i >= r2.row + r2.h; i--) {
          floorMap[i][r2.col] = DungeonGenerator.EMPTY;
        }
      }
    } else {
      return false;
    }
    return true;
  }

  private static linkRooms(floorMap: CellType[][], r1: Room, r2: Room) {
    if (r1.row >= r2.row && r1.row < r2.row + r2.h) {
      DungeonGenerator.linkStraightH(floorMap, r1, r2);
    } else if (r2.row >= r1.row && r2.row < r1.row + r1.h) {
      DungeonGenerator.linkStraightH(floorMap, r2, r1);
    } else if (r1.col >= r2.col && r1.col < r2.col + r2.w) {
      DungeonGenerator.linkStraightV(floorMap, r1, r2);
    } else if (r2.col >= r1.col && r2.col < r1.col + r1.w) {
      DungeonGenerator.linkStraightV(floorMap, r2, r1);
    } else {
      if (!DungeonGenerator.link2Steps(floorMap, r1, r2)) {
        DungeonGenerator.link2Steps(floorMap, r2, r1);
      }
    }
  }

  private static randomEvenOdd(min: number, max: number): number {
    if (max === min) return max;
    return min + Math.floor(Math.random() * Math.floor((max - min) / 2 + 1)) * 2;
  }

  private static addRoom(floorMap: CellType[][]): Room | undefined {
    const h = DungeonGenerator.randomEvenOdd(DungeonGenerator.MINSIZE, DungeonGenerator.MAXSIZE);
    const w = DungeonGenerator.randomEvenOdd(DungeonGenerator.MINSIZE, DungeonGenerator.MAXSIZE);
    const room: Room = {
      h,
      w,
      row: DungeonGenerator.randomEvenOdd(0, DungeonGenerator.ROWS - h - 2 * DungeonGenerator.BORDER) + DungeonGenerator.BORDER,
      col: DungeonGenerator.randomEvenOdd(0, DungeonGenerator.COLS - w - 2 * DungeonGenerator.BORDER) + DungeonGenerator.BORDER,
    };

    if (DungeonGenerator.isNotOverlapping(floorMap, room)) {
      for (let i = room.row; i < room.row + room.h; i++) {
        for (let j = room.col; j < room.col + room.w; j++) {
          floorMap[i][j] = DungeonGenerator.EMPTY;
        }
      }
      return room;
    }
    return undefined;
  }

  private static distance(a: Room, b: Room): number {
    const d2 = Math.pow(b.row - a.row, 2) + Math.pow(b.col - a.col, 2);
    return Math.sqrt(d2);
  }

  public static generate(config: Config = {}): Cell[][] {
    DungeonGenerator.ROWS = config.rows || 31;
    DungeonGenerator.COLS = config.cols || 51;
    DungeonGenerator.MAXSIZE = config.maxRoomSize || 7;
    DungeonGenerator.MINSIZE = config.minRoomSize || 3;
    DungeonGenerator.BORDER = config.padding || 2;
    DungeonGenerator.ATTEMPTS = config.maxAttempts || 500;
    DungeonGenerator.ROOMS = config.rooms || 15;

    const floorMap: CellType[][] = [];
    for (let i = 0; i < DungeonGenerator.ROWS; i++) {
      const row: CellType[] = [];
      for (let j = 0; j < DungeonGenerator.COLS; j++) {
        row.push(DungeonGenerator.WALL);
      }
      floorMap.push(row);
    }

    const roomsToLink: Room[] = [];
    const roomsLinked: Room[] = [];
    let i = 0;
    let r = 0;
    while (i < DungeonGenerator.ATTEMPTS && r < DungeonGenerator.ROOMS) {
      const newRoom = DungeonGenerator.addRoom(floorMap);
      if (newRoom) {
        roomsToLink.push(newRoom);
        r++;
      }
      i++;
    }

    roomsLinked.push(roomsToLink.pop()!);
    while (roomsToLink.length) {
      const r1 = roomsLinked[roomsLinked.length - 1];
      const r2 = roomsToLink.sort((a, b) => DungeonGenerator.distance(r1, a) - DungeonGenerator.distance(r1, b)).pop()!;
      DungeonGenerator.linkRooms(floorMap, r1, r2);
      roomsLinked.push(r2);
    }

    return floorMap.map(row =>
      row.map(cell => ({
        cellType: cell === DungeonGenerator.WALL ? 'wall' : 'empty',
      }))
    );
  }
}

export default DungeonGenerator;


// src/components/Dungeon.vue

<template>
  <div class="dungeon-map">
    <div v-for="(row, rowIndex) in dungeonMap" :key="rowIndex" class="row">
      <div v-for="(cell, colIndex) in row" :key="colIndex" :class="cell.cellType"></div>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted } from 'vue';
import DungeonGenerator from '../plugins/dungeonGenerator';
import { useDungeonStore } from '../stores/dungeon';

const dungeonStore = useDungeonStore();

type Cell = { cellType: 'wall' | 'empty' };
const dungeonMap = ref<Cell[][]>([]);

onMounted(() => {
    const config = {
        rows: 31,
        cols: 51,
        maxRoomSize: 7,
        minRoomSize: 3,
        padding: 0,
        maxAttempts: 500,
        rooms: 15
    };
    dungeonMap.value = DungeonGenerator.generate(config);
    dungeonStore.setDungeon(dungeonMap.value);
});
</script>

<style scoped>
.dungeon-map {
  display: grid;
  grid-template-columns: repeat(51, 20px); /* Assuming 51 columns */
  grid-gap: 0px;
}
.row {
  display: contents;
}
.wall {
  width: 20px;
  height: 20px;
  background-color: #000;
}
.empty {
  width: 20px;
  height: 20px;
  background-color: #fff;
}
</style>


// src/stores/dungeon/index.ts

import { defineStore } from 'pinia';

type Cell = { cellType: 'wall' | 'empty' };

interface DungeonState {
    dungeon: Cell[][];
}

export const useDungeonStore = defineStore('dungeon', {
    state: (): DungeonState => ({
      dungeon: [],
    }),
    actions: {
      setDungeon(map: Cell[][]) {
        this.dungeon = map;
      }
    }
});
  

// src/components/CharacterViewer.vue

<template>
  <div 
    class="character" 
    :style="{
      position: 'relative', 
      left: `${props.character.state.position.x}px`, 
      top: `${props.character.state.position.y}px`,
    }"
  >
    <img 
      class="character__img"
      :src="currentFrame" 
      :style="direction ? 'transform: scaleX(-1)' : ''"
      alt="Character Animation Frame"
    />
  </div>
</template>

<script setup lang="ts">
import { ref, watch, computed, onMounted, onUnmounted } from 'vue';
import { useSocketStore } from '../stores/socket';
import animations from '../animations.json';
import { useDungeonStore } from '../stores/dungeon';

const props = defineProps({
  userId: {
    type: String,
    required: true,
  },
  isOwn: {
    type: Boolean,
    required: true,
  },
  character: {
    type: Object,
    required: true,
  },
});

const socketStore = useSocketStore();
const dungeonStore = useDungeonStore();
const dungeonMap = dungeonStore.dungeon;

const frames = ref<string[]>([]);
const currentFrame = ref<string>('');
let frameIndex = 0;
let animationFrameId: number | null = null;

const preloadImages = (frameList: string[]) => {
  const promises = frameList.map(src => {
    return new Promise<void>((resolve, reject) => {
      const img = new Image();
      img.src = src;
      img.onload = () => resolve();
      img.onerror = () => reject(new Error(`Failed to load image ${src}`));
    });
  });

  return Promise.all(promises);
};

const updateFrames = async () => {
  frames.value = Object.values((animations as any).char[props.character.info.category][props.character.info.character][props.character.state.action]);
  await preloadImages(frames.value);
  currentFrame.value = frames.value[0];
  frameIndex = 0;
};

const startAnimation = () => {
  const frameDuration = 1000 / 10; // 10 fps

  const animate = () => {
    frameIndex = (frameIndex + 1) % frames.value.length;
    currentFrame.value = frames.value[frameIndex];
    setTimeout(() => {
      animationFrameId = requestAnimationFrame(animate);
    }, frameDuration);
  };

  animationFrameId = requestAnimationFrame(animate);
};

const startAction = (action: string) => {
  socketStore.updateUserAction(props.userId, props.character.info.character, action);
};

const stopAction = () => {
  socketStore.updateUserAction(props.userId, props.character.info.character, 'idle');
};

const direction = computed(() => {
  return props.character.state.direction === 'left';
});

const keys = ref<{ [key: string]: boolean }>({
  ArrowUp: false,
  ArrowDown: false,
  ArrowLeft: false,
  ArrowRight: false,
  ShiftLeft: false,
  ShiftRight: false,
});

const handleKeyDown = (event: KeyboardEvent) => {
  if (!props.isOwn) return;

  if (keys.value.hasOwnProperty(event.code)) {
    keys.value[event.code] = true;
  }

  const actionMap: { [key: string]: string } = {
    KeyZ: 'attack',
    KeyX: 'attack2',
    KeyC: 'attack3', 
    ArrowRight: 'walk',
    ArrowLeft: 'walk',
    ArrowUp: 'walk',
    ArrowDown: 'walk',
    Space: 'jump',
  };

  let action = actionMap[event.code];

  if (action) {
    if ((keys.value.ShiftLeft || keys.value.ShiftRight) && ['ArrowRight', 'ArrowLeft', 'ArrowUp', 'ArrowDown'].includes(event.code)) {
      action = 'run';
    }
    startAction(action);
  }
};

const handleKeyUp = (event: KeyboardEvent) => {
  if (!props.isOwn) return;

  if (keys.value.hasOwnProperty(event.code)) {
    keys.value[event.code] = false;
  }

  if (!Object.values(keys.value).some(key => key)) {
    stopAction();
  } else {
    if (keys.value.ArrowUp || keys.value.ArrowDown || keys.value.ArrowLeft || keys.value.ArrowRight) {
      const action = (keys.value.ShiftLeft || keys.value.ShiftRight) ? 'run' : 'walk';
      startAction(action);
    }
  }
};

const handleMovement = () => {
  if (!props.isOwn) return;

  let newPosition = { ...props.character.state.position };
  let direction: 'left' | 'right' = props.character.state.direction;

  const speedType = (keys.value.ShiftLeft || keys.value.ShiftRight) ? 'running' : 'walking';
  const speed = props.character.stats.speed[speedType];

  if (keys.value.ArrowUp) {
    const newY = newPosition.y - speed;
    if (dungeonMap[Math.floor(newY / 20)][Math.floor(newPosition.x / 20)].cellType !== 'wall') {
      newPosition.y = newY;
    }
  }
  if (keys.value.ArrowDown) {
    const newY = newPosition.y + speed;
    if (dungeonMap[Math.floor(newY / 20)][Math.floor(newPosition.x / 20)].cellType !== 'wall') {
      newPosition.y = newY;
    }
  }
  if (keys.value.ArrowLeft) {
    const newX = newPosition.x - speed;
    if (dungeonMap[Math.floor(newPosition.y / 20)][Math.floor(newX / 20)].cellType !== 'wall') {
      newPosition.x = newX;
      direction = 'left';
    }
  }
  if (keys.value.ArrowRight) {
    const newX = newPosition.x + speed;
    if (dungeonMap[Math.floor(newPosition.y / 20)][Math.floor(newX / 20)].cellType !== 'wall') {
      newPosition.x = newX;
      direction = 'right';
    }
  }

  socketStore.updateUserPosition(props.userId, newPosition, direction);

  requestAnimationFrame(handleMovement);
};

watch(() => props.character.info.character, () => {
  updateFrames();
});

watch(() => props.character.state.action, () => {
  updateFrames();
});

onMounted(() => {
  console.log(dungeonMap)
  updateFrames();
  startAnimation();
  window.addEventListener('keydown', handleKeyDown);
  window.addEventListener('keyup', handleKeyUp);
  requestAnimationFrame(handleMovement);
});

onUnmounted(() => {
  if (animationFrameId) {
    cancelAnimationFrame(animationFrameId);
  }
  window.removeEventListener('keydown', handleKeyDown);
  window.removeEventListener('keyup', handleKeyUp);
});
</script>

<style scoped lang="scss">
.character {
  position: absolute;
  display: block;

  &__img {
    width: 50px;
    height: auto;
  }
}
</style>


// src/App.vue

<template>
  <div v-if="true">
    <p>Connected: {{ isConnected }}</p>
    <div class="tabs">
      <button :class="{ active: currentTab === 'Gameplay' }" @click="currentTab = 'Gameplay'">Gameplay</button>
      <button :class="{ active: currentTab === 'enemy' }" @click="currentTab = 'enemy'">Enemy</button>
      <button :class="{ active: currentTab === 'chat' }" @click="currentTab = 'chat'">Chat</button>
    </div>

    <div class="chat-wrapper" v-if="currentTab === 'chat'">
      <div class="user-list">
        <div v-for="user in usersInSameLocation" :key="user.userId" class="user-card">
          <div class="user-chat-image"></div>
          <p>{{ user.userId }}</p>
          <p><strong>Character:</strong> {{ user.character.info.character }}</p>
          <p><strong>Action:</strong> {{ user.character.state.action }}</p>
          <p><strong>Location:</strong> {{ user.character.info.location }}</p>
        </div>
      </div>
      <ChatViewer />
    </div>

    <div class="menu">
      <button
        v-for="character in characters"
        :key="character"
        @click="selectCharacter(character)"
      >
        {{ character }}
      </button>
    </div>
  </div>

  <div class="viewers" v-if="currentTab === 'Gameplay'">
    <CharacterViewer
      v-for="user in usersInSameLocation"
      :key="user.userId"
      :user-id="user.userId"
      :is-own="user.userId === ownUserId"
      :character="user.character"
    />
  </div>

  <Dungeon />
</template>

<script setup lang="ts">
import { ref, onMounted, onUnmounted, computed } from 'vue';
import CharacterViewer from './components/CharacterViewer.vue';
import ChatViewer from './components/ChatViewer.vue';
import Dungeon from './components/Dungeon.vue';
import { useSocketStore } from './stores/socket';
import animations from './animations.json';

const currentUserId = ref<string>('');
const determineUserId = () => {
  const users = ['Kelly', 'Roh'];
  const randomIndex = Math.floor(Math.random() * users.length);
  currentUserId.value = users[randomIndex];
  if (!currentUserId.value) {
    return users[randomIndex];
  } else {
    if (currentUserId.value === 'Kelly') return 'Roh'
    else return 'Kelly'
  }
};

const currentTab = ref<'Gameplay' | 'enemy' | 'chat'>('Gameplay');
const socketStore = useSocketStore();
const ownUserId = ref<string>(determineUserId());

const characters = ref(Object.keys((animations as any).char['ally']));

const selectCharacter = (character: string) => {
  socketStore.updateUserCharacter(currentUserId.value, character);
};

onMounted(() => {
  socketStore.connect(ownUserId.value);
});

onUnmounted(() => {
  socketStore.disconnect();
});

const isConnected = computed(() => socketStore.isConnected);

const usersInSameLocation = computed(() => {
  const ownUser = socketStore.users.find(user => user.userId === ownUserId.value);
  if (!ownUser) return [];
  const location = ownUser.character.info.location;
  return socketStore.users.filter(user => user.character.info.location === location);
});
</script>

<style scoped lang="scss">
.tabs {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;

  & button {
    margin: 5px;
    padding: 10px;
    cursor: pointer;

    &.active {
      background-color: blueviolet;
      color: white;
      border: none;
      border-radius: 4px;
    }
  }
}

.user-list {
  display: flex;
  flex-direction: column;
  gap: 10px;
  margin-top: 20px;
}

.user-card {
  display: flex;
  flex-direction: row;
  align-items: center;
  gap: 15px;
}

.user-chat-image {
  background-color: #f0f0f0;
  border: 1px solid #ccc;
  border-radius: 50%;
  padding: 5px;
  width: 48px;
  height: 48px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.user-card p {
  margin: 5px 0;
}

.viewers {
  display: flex;
  flex-direction: row;
  gap: 10px;
  align-items: center;
  margin-top: 20px;
}

.chat-wrapper {
  display: flex;
  flex-direction: row;
  gap: 20px;
}

.menu {
  margin-bottom: 20px;
}

.menu button {
  margin: 0 5px;
}

.actions {
  margin-bottom: 20px;
}

.actions button {
  margin: 0 5px;
}

</style>
